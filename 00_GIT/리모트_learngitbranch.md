# learn git branch 리모트 파트 

링크 : https://learngitbranching.js.org/

## 0. Remote Introduction
- 클라우드 컴퓨팅을 떠올리면 git remote의 이면에 수많은 마법이 부려지고 있을 것 같지만, 사실 git remote 또 하나의 컴퓨터에 있는 여러분의 저장소의 복사본일 뿐이다.
- 일반적으로 인터넷을 통해서 이 또 하나의 컴퓨터와 커밋을 주고받는 등의 대화를 할 수 있다.
- 원격저장소 장점
  - 1) 원격 저장소는 백업으로서의 역할을 훌륭하게 수행함
    - 로컬 git 저장소는 파일들을 이전의 상태로 되돌리는 기능을 가지고 있음
    - 하지만 그 모든 정보가 로컬(내 PC)에 저장되어 있음
    - git 저장소를 다른 컴퓨터가 복사본으로 가지고 있으면 로컬 데이터를 다 잃더라도 다른 컴퓨터에 남아있는 복사본으로 다시 출발 할 수 있음
  - 2) 원격 저장소를 통해 코딩을 다른 사람들과 함께 할 수 있다. 
    - 프로젝트의 복사본이 어느 곳에선가 호스트되기 때문에 여러분의 친구가 프로젝트에 아주 쉽게 기여할 수 있게 됨(최근의 변화를 pull하거나)
 - 원격 저장소에서의 활동을 시각화해주는 웹 사이트들을 사용하는 것이 추세 (GitHub 또는 Phabricator등이 있다)


# 1.1 Clone Intro
- git clone은 원격 저장소의 복사본을 로컬에 생성할때 사용하는 명령어
- Git 브랜치 배우기에서는 이 명령어를 살짝 다르게 사용
- git clone이 로컬 저장소에서 원격 저장소를 생성해냄
- 물론 실제 명령어와 반대로 작동하는 것이지만 클론과 원격 저장소 사이의 연결관계를 이해하는데 도움이되서 이렇게 함

```
git clone //원격 저장소를 가지게 됨. 구분을 하기위해 조금 모양이 다른것 말고는 둘이 똑같게 생긴걸 알 수 있다.
```

# 1.2 Remote Branches
- git clone 후의 변화 : 로컬 저장소에 o/master라고하는 새 브랜치가 생김 (이런 종류의 브랜치는 _원격_브랜치라고 불림)
- 원격 브랜치는 특정한 목적을 제공하기 때문에 특별한 속성들이 있다.
   - 원격 브랜치는 원격 저장소의 _상태_를 반영함(가장 최근 원격 원격저장소와 작업을 했을때를 기준으로). 
   - 원격 브랜치는 로컬에서의 작업과 공개적으로 되고있는 작업의 차이를 이해하는데 도와줌
   - 원격 브랜치는 체크 아웃을 하게 되면 분리된 HEAD 모드로 가게되는 특별한 속성이 있다.
   - Git은 이 브랜치들에서 직접 작업할 수 없기 때문에 일부로 이렇게 함
   - 우리는 다른곳에 작업을 하고 원격 저장소와 우리의 작업을 공유해야함(그 이후에 원격 브랜치가 갱신됨)

- o/ 란?
  - 원격 브랜치 또한 (필수적인) 이름짓기 규약이 있다
```
<remote name>/<branch name>
```
   - 이런 이유로, 만약 o/master라는 이름의 브랜치를 보게되면, 브랜치의 이름은 master이고 원격 저장소의 이름은 o인 것임
   - 대부분의 개발자들은 자신의 주 원격 저장소를 o가 아닌 origin이라고 지음
   - 사실 보통 다 이렇게 쓰기 때문에 git은 저장소를 git clone하게 되면 원격 저장소의 이름을 origin이라고 자동으로 설정해놓음
   - 부득이하게도 origin이라는 풀네임은 우리 UI에 안 맞아서 o로 간략히 표현:( 진짜 git을 사용하게되면 원격저장소가 아마 origin이라고 되있을 것임)

```
git commit
git checkout o/master
git commit
// git은 우리를 분리된 HEAD 모드로 만들고 새로운 커밋을 추가해도 o/master를 갱신하지 않는다. 이것은 o/master가 원격 저장소가 갱신될때만 갱신되기 때문이다.
// 원격 브랜치는 원격 저장소의 상태를 반영하기만 한다
```

# 1.3 Git Fetchin’
- git 원격 작업들은 결국 서로다른 저장소에서 데이터를 주고 _받는_것에 불과하다는것을 알 수 있다.
- 우리가 커밋들을 주고 받을수 있는 한, git을 바탕으로하는 모든 종류의 업데이트를 공유할 수 있다(작업, 새로운 파일들, 새로운 아이디어, 러브레터 등...).
- 여기서는 원격 저장소에서 데이터를 가져오는 방법을 배워볼 것임! -- 이를 위한 명령어는 git fetch라고 함
- 먼저 알아두고 넘어갈것이 있는데 우리가 원격 저장소와 작업을 해서 상태가 변하면 _원격_브랜치들 또한 그 변경들을 반영한다.

- git fetch의 2 STEP
  - 원격 저장소에는 있지만 로컬에는 없는 커밋들을 다운로드 받는다.
  - 그리고 우리의 원격 브랜치가 가리키는곳을 업데이트함 (예를들어, o/master)

- git fetch는 본질적으로 로컬_에서 나타내는 원격 저장소의 상태를 _실제 원격 저장소의 (현재)상태와 동기화한다.
- 원격 브랜치는 가장 최근 원격 원격저장소와 작업을 했을때를 기준으로 원격 저장소의 상태를 반영한다고 했다. git fetch가 그러한 작업중에 하나다!
- git fetch는 일반적으로 원격 저장소와 인터넷을 통해 접근한다(http:// 또는 git://와같은 프로토콜로).

- 그러나 git fetch는 로컬 상태는 전혀 바꾸지 않는다. master 브랜치도 업데이트하지 않고 파일 시스템의 모습이던 그 어떤것도 바꾸지 않는다.
- 앞의 과정에 필요한 데이터를 다운로드는 하지만, 실제로 로컬 파일들이나 브랜치를 변경하지는 않는다 (= 다운로드 단계라고 생각하면 됨)

```
git fetch
//  커밋 C2 와 C3가 우리의 로컬 저장소로 다운로드 되었고, 원격 브랜치 o/master가 이것을 반영하기 위해 업데이트 되었다.
```


# 1.4 Git Pullin’
- 작업을 업데이트해서 반영하기
- 새 커밋들을 로컬에 내려받은 이후에는 그냥 다른 브랜치에있는 일반 커밋처럼 활용할 수 있다 :
   - 1) git cherry-pick o/master
   - 2) git rebase o/master
   - 3) git merge o/master
   - 4) 기타 등등
- 사실 원격 저장소의 변경을 fetch하고 그이후에 merge하는 작업의 과정이 워낙 자주있는 일이라서 git은 이 두가지를 한번에 하는 명령을 제공한다! -> git pull 명령어

```
git fetch; git merge o/master
// C3를 fetch로 내려 받고 git merge o/master로 우리의 작업으로 병합함. 이제 master 브랜치는 원격 저장소의 새 작업들을 반영하게 됨(ex origin입니다).
```

대신에 git pull을 사용하면?
```
git pull
// 똑같은 일이 일어남! 이렇게 git pull은 본질적으로 git fetch후에 내려받은 브랜치를 병합하는 과정의 단축이다.
```

# 1.5 Fakeing Teamwork
- 원격 저장소에서 일어난 변경들을 어떻게 로컬로 가져올것인지

- 불가피하게 그 변경들을 만들어야 되는데, 원격 저장소가 동료 / 친구 / 협력자등에 의해 특정 브랜치나 여러개의 커밋이 갱신되는 경우를 표현할 필요가 있다. 즉 우리는 Teamwork를 "가장"할 필요가 있다.

- 이런 문제를 해결하기 위해서 git fakeTeamwork 명령이 생겨났다.

- fakeTeamwork의 default는 원격 master에 간단히 하나의 커밋을 하는것이다.

```
// 명령어에 추가할 커밋의 갯수나 어떤 브랜치에 추가할지 지정하는것도 가능하다. 다음과 같이 명령어 뒤에 추가하면 된다.
git fakeTeamwork 
// 원격 저장소에 새로운 커밋이 갱신되었다. 아직 git fetch를 하지 않았기 때문에 로컬로 내려받아지지는 않았다.
git fakeTeamwork foo 3 // 3개 만들어짐
// 하나의 명령어로 팀원이 원격저장소의 foo 브랜치에 세개의 커밋을 push한것처럼 가장했다.
```

```
// 원격 저장소를 하나 만들고(git clone), 원격 저장소에 몇가지 가짜 변경을 만들고 로컬에서 커밋하고 원격의 변경들을 가져오세요. Goal과 같은 결과가 나오면 됩니다. 몇개의 레슨이 하나에 있다고 보면 되겠네요!.
git clone
git fakeTeamwork master 2 // 2개 만듬
git commit
git pull
```

# 1.6 Git Pushin
- 작업을 다른 사람들과 공유하려면?
- git pull의 반대는 - git push
- git push는 변경을 정한 원격저장소에 업로드하고 그 원격 저장소가 새 커밋들을 합치고 갱신하게 함. git push가 끝나고 나면, 다른 사람들은 원격저장소에서 우리의 작업을 내려받을수 있게됨
- git push를 작업을 "공개"하는 과정이라고 생각해도 됨
- note :  git push를 매개변수 없이 사용하는 디폴트는 push.default라 불리는 git의 설정에 따라 결정 됨. 이 설정의 기본값은 git 버전에 따라 다르지만, 여기서는 upstream을 값으로 사용함. 한번씩 확인해볼 필요가 있다.
```
// 여기 원격저장소에는 없는 변경이 있습니다. 이것들을 업로드 해 봅시다!
git push
// 원격 저장소가 커밋 C2를 받았고, 원격 저장소의 브랜치 master가 C2라는 지점까지 갱신 됨. 그리고 원격 저장소의 반영인 우리의 원격 브랜치 (o/master)또한 잘 갱신 됨. 모든게 동기화되어 있다.
```

```
// 두개의 새 커밋을 원격 저장소에 공유해봅시다.
git commit
git commit
git push
```

# 1.7 Diverged History

- History가 꼬일때 문제 발생(한명이 clone해서 부가기능을 만들기 시작했는데, 다른사람이 개발을 잔뜩해서 부가기능은 구 버전을 기반으로 한 작업이 되어버림)
- 이런 경우, git push가 어떻게 수행될지 애매해짐. ( git은 원격 저장소를 여러분이 작업했던 월요일의 상태로 되돌려야 할까요? 아니면 새 코드를 건들지 않고 여러분의 코드만 추가해야 되나요? 아니면 여러분의 작업은 뒤 떨어졌기 때문에 완전히 무시해야되나요?)
- 따라서 git은 push를 하지 못하도록 함 ( 코드를 올리기 전에 먼저 원격 저장소의 최신 상태를 합치도록 강제함)

![image](https://user-images.githubusercontent.com/61506233/97858044-eb23be00-1d41-11eb-88c8-56db1e9914a1.png)

- 이런경우 push가 안되는거!! (최근 커밋 C3가 원격저장소의 C1을 기반으로 하기 때문에)
- 그러면 어떻게 하면 되냐면 원격브랜치의 최신상태를 기반으로 하게 만들면 됨


- 해결책 1) 가장 간결한 방법은 rebase를 통해 작업을 옮기는것
```
git fetch  // 원격저장소의 변경정보를 가져옴
git rebase o/master // 새 변경들로 작업들을 리베이스(한줄로 정렬)
git push // 이러면 푸시가 가능해짐!!

```
- 이거 결과는 한줄로 톡톡톡


- 해결책 2) merge
  - git merge가 작업을 옮기지는 않지만(merge 커밋을 생성함). git에게 원격 저장소의 변경을 합쳤다고 알려주는 방법중에 하나임이제 원격 브랜치가 우리 브랜치의 부모기 되었기때문, 우리의 커밋이 원격 브랜치의 모든 커밋을 반영했다는 뜻
```
git fetch
git merge o/master // 작업을 병함
git push

```
![image](https://user-images.githubusercontent.com/61506233/97858458-87e65b80-1d42-11eb-881f-7018edbb3952.png)

- 해결책 3) 명령어를 좀더 적게 쓰는 방법
  - git pull = fetch + merge
```
git pull --rebase
git push
// 해결책 1) 이랑 그림이 같아짐!
```

```
git pull
git push
// 해결책 2) 랑 그림이 같아짐!
```



```
git clone // 여러분의 저장소를 clone 하세요
git fakeTeamwork master 1 // 가짜 팀워크를 만드세요 (1개의 커밋)
git commit // 여러분의 작업도 커밋하세요 (1개의 커밋)


//여러분의 작업을 리베이스를 통해 공유하세요
git pull --rebase
git push
```

# 1.8 Locked branch Master

- 원격저장소 거부! (Remote Rejected!)
- 규모가 큰 개발팀에서 일하는 경우, 보통 원격저장소의 master 브랜치는 잠겨있다(locked)
- 그래서 변경사항을 적용하려면 pull request 과정을 거쳐야한다.
- 만약에 우리가 로컬 저장소의 master 브랜치에서 커밋을 한 후, push하려고 시도한다면 다음의 오류 발생
```
! [remote rejected] master -> master (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)
```
- 원격 저장소는 자신의 master 브랜치에 대한 직접적인 커밋을 제한함. 왜냐하면 push 대신에 pull request가 쓰여야 한다는 규칙이 원격 저장소의 master 브랜치에는 적용되어 있기 때문
- 브랜치를 따로 만들어 작업한 다음, 그것을 push하고 pull request를 하려 함. 하지만 그걸 잊고 실수로 master 브랜치에서 직접 커밋을 해버렸다! 이제 변경 사항을 push 하지도 못하고 옴짝달싹 못하는 상황이 되어버림

- 해결책?
   - feature 라는 이름의 다른 브랜치를 만들어 원격 저장소에 push. 그리고 원격 저장소와 동기화될 수 있도록 로컬 저장소의 master 브랜치를 reset. 그렇지 않으면 다음에 pull을 시도할 때 문제가 발생하거나, 다른 협업자들의 커밋과 충돌할 수 있음



```
// feature 라는 이름의 다른 브랜치를 만들어 원격 저장소에 push 하세요 그리고 원격 저장소와 동기화될 수 있도록 로컬 저장소의 master 브랜치를 reset하세요. 그렇지 않으면 여러분이 다음에 pull을 시도할 때 문제가 발생하거나, 다른 협업자들의 커밋이 여러분의 커밋과 충돌할 수도 있습니다.

git reset --hard o/master
git checkout -b feature C2
git push origin feature

```
